# Decision Log

Project: greenlight

## Decisions

| # | Decision | Context | Chosen | Rejected | Date | Source |
|---|----------|---------|--------|----------|------|--------|
| D-1 | Upgrade installation detection | Upgrade command needs to find existing installations without requiring user to specify scope | Auto-detect by scanning for `.greenlight-version` at known locations | Require `--global`/`--local` flag; Store install registry | 2026-02-09 | design |
| D-2 | Upgrade approach | How users get updates applied to their installation | Re-install with current binary (diff-based: add new, remove obsolete, update changed) | Self-updating binary that downloads from GitHub | 2026-02-09 | design |
| D-3 | CLAUDE.md strategy preservation across upgrades | Upgrade needs to know what conflict strategy was used during original install | Store strategy in version file (4th line: `conflict={strategy}`) | Separate config file; Store in `.greenlight/config.json` | 2026-02-09 | design |
| D-4 | Atomic install mechanism | Prevent partial installations from leaving stale files when install fails midway | Staging directory at `{targetDir}/.greenlight-staging-{pid}/` (same filesystem for atomic rename) | `/tmp/` staging (cross-filesystem); In-place overwrite with rollback log | 2026-02-09 | design |
| D-5 | Staging directory naming convention | Need unique, identifiable staging directories that can be cleaned up if process dies | `.greenlight-staging-{pid}/` using process ID | UUID-based naming; Timestamp-based naming | 2026-02-09 | design |
| D-6 | Stale staging directory cleanup | What happens when a previous install/upgrade crashes and leaves a staging directory behind | Auto-clean on install/upgrade (scan and remove before starting), report in doctor | Manual cleanup only; Clean on every command | 2026-02-09 | design |
| D-7 | Doctor command exit codes | Whether doctor should signal issues via exit code or always exit 0 | Exit 0 when healthy, exit 1 when any issues found (including outdated version) | Always exit 0 (informational only); Tiered codes (0/1/2) | 2026-02-09 | design |
| D-8 | Orphan file detection scope in doctor | How broadly to scan for files that should not be in the installation directory | Only `.md` files in known greenlight directories (`agents/`, `commands/gl/`, `references/`, `templates/`) | All files in `.claude/`; No orphan detection | 2026-02-09 | design |
| D-9 | Named constants location | Where to define shared constants for directory names, permissions, file names | Single `internal/installer/constants.go` file | Constants spread across packages; Shared `constants` package | 2026-02-09 | design |
| D-10 | Flag parsing fix approach | `ParseConflictStrategy` uses magic number string slicing (`arg[:14]`) which is brittle | `strings.HasPrefix` + `strings.TrimPrefix` (minimal change, fixes the issue) | Full `flag` package adoption; Third-party CLI framework | 2026-02-09 | design |
| D-11 | Upgrade output verbosity | How much detail to show during upgrade | Verbose by default: list every file action (added/removed/updated/unchanged), summary at end | Quiet by default with `--verbose` flag; Summary only | 2026-02-09 | design |
| D-12 | Version file backward compatibility | How to handle existing 3-line version files when format extends to 4 lines | Lenient parsing: read line by line, 4th line optional, defaults to `keep` if missing | Strict parsing requiring migration; Separate metadata file | 2026-02-09 | design |
| D-13 | Doctor state validation depth | How deeply to validate `.greenlight/` state files (config.json, GRAPH.json, etc.) | Structural only: file exists and is valid JSON where applicable | Deep schema validation; No validation at all | 2026-02-09 | design |
| D-14 | Error output destination in command handlers | Whether errors go to stderr or the injected io.Writer | Command handlers write to injected `io.Writer` (preserves testability), only `main.go` writes to `os.Stderr` | All errors to stderr; All errors to stdout | 2026-02-09 | design |
| D-15 | Scope lock source for circuit breaker | How the implementer determines which files are in-scope for a slice | Inferred from contracts (default) with optional `files_in_scope` override in GRAPH.json for edge cases | Manual allowlist maintained by architect; Pure inference with no override | 2026-02-18 | design:circuit-breaker |
| D-16 | Attempt counter granularity | Whether to track failed attempts per test, per slice, or hybrid | Per-test tracking (max 3) with slice-level ceiling (max 7 total failures) | Per-test only (misses failure redistribution); Per-slice only (too coarse) | 2026-02-18 | design:circuit-breaker |
| D-17 | Rollback mechanism for circuit breaker | How to preserve clean state before implementation attempts | Lightweight git tags (`greenlight/checkpoint/{slice_id}`) | Git commits with checkpoint prefix (pollutes history); Git stash (unnamed, lossy) | 2026-02-18 | design:circuit-breaker |
| D-18 | /gl-debug integration level | How the manual diagnostic command interacts with the /gl:slice pipeline | Standalone diagnostic (read state, produce report, user decides next action), structured for future pause/resume | Integrated with /gl:pause (too complex now); Full pipeline controller | 2026-02-18 | design:circuit-breaker |
| D-19 | CLAUDE.md circuit breaker integration pattern | Where the full circuit breaker protocol lives and how CLAUDE.md references it | 5-line hard rule in CLAUDE.md + full protocol in `references/circuit-breaker.md` | Full protocol in CLAUDE.md (~50 lines, bloats shared doc); Brief reference only (agents could ignore) | 2026-02-18 | design:circuit-breaker |
| D-20 | Diagnostic report structure | Whether the circuit break report is free-form or structured | Structured fields with consistent naming, rendered as markdown (human-readable now, machine-parseable later) | Free-form markdown (inconsistent); JSON output (not human-friendly) | 2026-02-18 | design:circuit-breaker |
| D-21 | Slice-level failure ceiling threshold | How many total failures across all tests trigger a slice-level circuit break | 7 total failures (at least 3 tests attempted, enough signal that problem is systemic) | 5 (too aggressive, trips on 2 tests); 10 (too permissive, 3+ tests fully exhausted before detection) | 2026-02-18 | design:circuit-breaker |
| D-22 | Checkpoint tag cleanup timing | When to delete the rollback checkpoint tags | At slice completion (Step 10 of /gl:slice) -- rollback stays available throughout implementation | Immediately after test passes (loses rollback if later test breaks earlier one); Never (tag namespace pollution) | 2026-02-18 | design:circuit-breaker |
| D-23 | Rejection feedback isolation for test writer | What context the test writer receives when spawned after a user rejection at the verification tier gate | User's verbatim behavioral feedback + contract + acceptance criteria. No implementation details, no test source from current cycle. | Include implementation code (breaks agent isolation); Include test source (breaks TDD integrity) | 2026-02-19 | design:verification-tiers |
| D-24 | Tier resolution across multiple contracts in a slice | How to determine a slice's effective verification tier when contracts have different tiers | Highest tier wins + aggregation. verify > auto. All acceptance criteria aggregated into one checkpoint per slice. | Per-contract checkpoints (too many interruptions); Per-slice config only (loses contract granularity) | 2026-02-19 | design:verification-tiers |
| D-25 | visual_checkpoint config toggle backward compatibility | What happens to the existing `config.workflow.visual_checkpoint` boolean now that verification tiers subsume it | Keep in config but deprecate with log warning. Tiers in contracts supersede it. Default `verify` tier already provides human verification. | Remove from config (breaking change for existing configs); Add new `default_verification_tier` config field (unnecessary -- tiers belong in contracts) | 2026-02-19 | design:verification-tiers |
| D-26 | Rejection counter scope | Whether to track rejection count per-contract or per-slice, and escalation threshold | Per-slice counter, escalation at 3 rejections. A slice is the unit of work. | Per-contract (3 rejections each, too granular -- user re-scoping decision applies to the whole slice) | 2026-02-19 | design:verification-tiers |
| D-27 | Gap classification user experience | How users classify why their rejection feedback doesn't match the slice output | Orchestrator presents actionable options ("tighten tests" / "revise contract" / "provide more detail") that implicitly map to internal gap types. User picks; orchestrator routes. | Ask user to classify directly using internal taxonomy ("test gap / implementation gap / contract gap"); Auto-classify with AI heuristics (unreliable) | 2026-02-19 | design:verification-tiers |
| D-28 | Verification tiers reference file location | Whether verification tier protocol extends existing verification-patterns.md or gets its own file | New `references/verification-tiers.md` following the `references/circuit-breaker.md` pattern | Extend `references/verification-patterns.md` (mixes automated verification with human acceptance -- different concerns, different audiences) | 2026-02-19 | design:verification-tiers |
| D-29 | Tier simplification: two tiers not three | Whether to keep auto/review/demo (three tiers) or collapse to auto/verify (two tiers) | Two tiers: `auto` and `verify`. Renamed `demo_steps` to `steps` as optional field under `verify`. Both `acceptance_criteria` and `steps` are optional under `verify`. | Three tiers (auto/review/demo) -- the review/demo distinction is artificial. In both cases the user looks at output and confirms intent. The contract author shouldn't choose between "check a list" and "walk through steps." | 2026-02-19 | design:verification-tiers |

## Prior Decisions (from previous milestones)

These decisions were made during earlier design sessions and remain in effect.

| # | Decision | Date | Source | Status |
|---|----------|------|--------|--------|
| P-1 | Strict error on invalid `--on-conflict` values | 2026-02-08 | cli-stabilisation | active |
| P-2 | `cli.Run` accepts `io.Writer` parameter for testability | 2026-02-08 | cli-stabilisation | active |
| P-3 | Uninstall removes conflict artifacts (backup, greenlight copy) | 2026-02-08 | cli-stabilisation | active |
| P-4 | `--verify` flag for SHA-256 content hash comparison on check | 2026-02-08 | cli-stabilisation | active |
| P-5 | Wrapped contracts in CONTRACTS.md with `[WRAPPED]` tag | 2026-02-09 | brownfield-and-docs | active |
| P-6 | gl-wrapper breaks agent isolation deliberately (locking tests only) | 2026-02-09 | brownfield-and-docs | active |
| P-7 | File mapping always runs, coverage command optional | 2026-02-09 | brownfield-and-docs | active |
| P-8 | Separate Wrapped Boundaries section in STATE.md | 2026-02-09 | brownfield-and-docs | active |
| P-9 | Markdown content tests read actual `src/` files via `os.ReadFile` | 2026-02-09 | brownfield-and-docs | active |
| P-10 | Task-based summary generation (not separate agent) | 2026-02-09 | brownfield-and-docs | active |
| P-11 | STATE.md (compact machine view) + ROADMAP.md (rich human view) coexist | 2026-02-09 | brownfield-and-docs | active |
| P-12 | Milestone-scoped design sessions via gl-designer | 2026-02-09 | brownfield-and-docs | active |
