# State Format Reference

How Greenlight stores and reads project state. Two formats are supported indefinitely: file-per-slice and legacy. This document is read-only at runtime — commands read it for format rules, they do not modify it.

---

## 1. State Format Detection

Detection is a single, deterministic directory check. No heuristics, no scanning.

### Detection Flow

```
1. Does .greenlight/slices/ exist?
   YES → use file-per-slice format
   NO  → does .greenlight/STATE.md exist?
         YES → use legacy format
         NO  → no state found — suggest /gl:init
```

The check is zero-cost: one `stat()` call on a directory path. Commands never scan for state in unexpected locations.

### Rules

- If `.greenlight/slices/` exists, always use file-per-slice. Do not fall back to legacy even if STATE.md also exists.
- If neither `slices/` nor `STATE.md` exists, raise `NoStateFound` and suggest `/gl:init`.
- Detection logic is deterministic: the same filesystem state always produces the same result.

---

## 2. File-Per-Slice Format

Each slice has its own file in `.greenlight/slices/`. This is the current format created by `/gl:init` from version 1.4 onwards.

### Structure

```
.greenlight/
  slices/
    S-1.md
    S-2.md
    S-3.md
    ...
  project-state.json
  STATE.md          ← generated summary, do not edit manually
```

### Files

- **`slices/{slice-id}.md`** — one file per slice, schema defined in `templates/slice-state.md`
- **`project-state.json`** — machine-readable project metadata (milestone list, slice graph, config snapshot)
- **`STATE.md`** — generated human-readable summary, regenerated after every write (D-34)

### Schema

The schema for each slice file is defined in `templates/slice-state.md`. Fields, valid status values, step values, and frontmatter format are all specified there.

### Reading

To read project state in file-per-slice format:

```
1. List .greenlight/slices/*.md
2. Parse frontmatter from each file
3. Skip and warn on CorruptSliceFile
4. Treat SlicesDirectoryEmpty as zero slices
5. Merge with project-state.json for milestone and graph data
```

---

## 3. Legacy Format

The legacy format uses a single `STATE.md` file at `.greenlight/STATE.md`. This format was used prior to version 1.4.

### Characteristics

- Single file contains all slice state
- Human-edited directly
- No per-slice file separation
- Schema defined by the state template (`templates/state.md`)

### Support

Legacy format is supported indefinitely (D-37). There is no plan to remove it. Commands that read state work identically whether the project uses file-per-slice or legacy format. The user experience is the same in both cases.

Migration from legacy to file-per-slice is available via `/gl:migrate-state` (D-32), but is never triggered automatically (no automatic migration).

---

## 4. Concurrent Access Patterns

File-per-slice format is designed for concurrent agent access without coordination overhead.

### Each Session Writes Its Own File

When multiple agents run in parallel, each agent works on a different slice and therefore writes to a different file. Concurrent sessions never touch the same file when working on separate slices.

### No File Locking

No file locking is used (NFR-1). The file-per-slice design makes locking unnecessary for the common case: parallel agents on parallel slices. The only conflict scenario is two agents claiming the same slice simultaneously, which the advisory session field handles.

### Advisory Session Tracking

The `session` field in slice frontmatter is advisory. It records which agent is working on a slice, but it does not prevent other agents from writing to the same file. Before claiming a slice with a non-empty session field, commands warn the user. They do not block.

This is intentional: hard locking would require a lock server or filesystem coordination that adds complexity without proportional benefit. Advisory tracking is sufficient for the coordination level Greenlight requires.

---

## 5. STATE.md Regeneration

In file-per-slice format, `STATE.md` is a generated summary. It is regenerated after every write to any slice file (D-34).

### Header Comment

Every generated `STATE.md` begins with:

```markdown
<!-- GENERATED by greenlight — do not edit manually -->
```

This header comment signals that the file is machine-generated. Manual edits will be overwritten on the next slice write.

### Format

The generated STATE.md format matches DESIGN.md section 4.6. It includes:
- Project overview
- Slice table with current statuses
- Progress bar
- Current slice and step
- Test summary

### Trigger

Regeneration is mandatory after every slice file write. No write operation completes without regenerating STATE.md. This ensures the summary is always current.

---

## 6. Crash Safety

Slice file writes use write-to-temp-then-rename to prevent partial writes from corrupting state.

### Protocol

```
1. Write new content to a temp file in .greenlight/slices/ (same filesystem)
2. Rename temp file to target path atomically
3. On rename failure, clean up temp file and report error
```

### POSIX Atomicity

The temp file is written to the same filesystem as the target (`.greenlight/slices/`). POSIX guarantees that `rename()` within the same filesystem is atomic — the target either has the old content or the new content, never a partial write. This prevents corrupt slice files from crashes or interruptions during write.

### Temp File Naming

Temp files use the pattern `{slice-id}.tmp` in `.greenlight/slices/`. They are cleaned up on success or failure. If a `.tmp` file is found on startup (indicating a prior crash), it is deleted before processing.

---

## 7. Backward Compatibility

Both formats are supported indefinitely. No format is deprecated. No migration is required.

### Guarantees

- **Both formats indefinite support.** File-per-slice and legacy STATE.md are both first-class formats. Neither will be removed.
- **No dual-write.** Commands write to one format only — the format detected at startup. There is no dual-write to both formats simultaneously (D-38).
- **Zero-cost detection.** Format detection is a single directory existence check. It adds no measurable overhead to command startup.
- **No automatic migration.** The format detected at startup is used as-is. `/gl:migrate-state` (D-32) is available for explicit migration, but it is never triggered automatically.

### Adding New Slices

When `/gl:add-slice` is run on a legacy-format project, it adds to STATE.md. When run on a file-per-slice project, it creates a new slice file. The command behaviour is identical from the user's perspective.

---

## Errors

### NoStateFound

Neither `.greenlight/slices/` nor `.greenlight/STATE.md` exists. The project has not been initialised.

**Action:** Suggest running `/gl:init` to create initial project state.

### CorruptSliceFile

A file in `.greenlight/slices/` has invalid frontmatter — missing `---` delimiters, non-flat structure, or unreadable content.

**Action:** Skip the corrupt file and warn the user. Continue processing remaining valid files. Include the corrupt file path in the warning so the user can fix or delete it manually.

### SlicesDirectoryEmpty

`.greenlight/slices/` exists but contains no `.md` files.

**Action:** Treat as zero slices. This is not an error condition — it is a valid state immediately after `/gl:init` before any slices are added. Commands that list slices return an empty list.

---

## Invariants

1. **Reference read-only at runtime.** This document is never modified by commands. It describes format rules — it does not implement them.
2. **Detection logic is deterministic.** Given the same filesystem state, format detection always returns the same result. No randomness, no environment-dependent branching.
3. **STATE.md regeneration is mandatory.** Every slice write must regenerate STATE.md. Commands that skip regeneration violate this invariant.
4. **Concurrent sessions never touch the same file.** When working on separate slices, concurrent agents write to separate files. The file-per-slice design makes this the default, not an exception to enforce.
